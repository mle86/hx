#!/usr/bin/perl
use Time::HiRes qw(ualarm);
use Term::ReadKey qw(GetTerminalSize);
use strict;
use FindBin;
use lib $FindBin::Bin;
use vars qw(
	$c_sym $c_contsym $c_meta $c_followsep $c_rpt
	$c_date $c_host $c_app
	$c_loglevel $c_loglevel_warn $c_loglevel_err
	$c_info $c_info_prefix
	$c_trace $c_stack $c_stack_msg
	$c_exception_scn $c_exception_fqcn $c_exception_code $c_exception0
	$c_message
	$c_http_success $c_http_redir $c_http_client_error $c_http_client_failure $c_http_server_error
);
use Regexes;
use Const;
use Output;


## Color constants:  ###########################################################

# Base color configuration:
our $c_sym = '[33m';
our $c_contsym = '[38;2;113;97;25m';
our $c_meta = '[38;2;114;204;204m';
our $c_followsep = '[32m'.$c_faint;

# Detailed color configuration:
our $c_date = $c_sym;
our $c_host = $c_sym;
our $c_app = $c_sym;
our $c_loglevel = $c_sym;
our $c_loglevel_warn = '[38;5;220m';
our $c_loglevel_err = '[38;2;255;145;36m';
our $c_info = '[38;5;243m';
our $c_info_prefix = '[38;2;125;117;83m';
our $c_trace = $c_info;
our $c_stack = $c_info;
our $c_stack_msg = $c0;
our $c_rpt = '[34m';
our $c_exception_fqcn = $c_unbold;
our $c_exception_scn  = $c_bold;
our $c_exception_code = $c_bold;
our $c_exception0 = $c_unbold;
our $c_message = $c0;

our $c_http_success        = '[38;2;98;214;113m';
our $c_http_redir          = '[38;2;202;214;98m';
our $c_http_client_error   = '[38;2;155;72;72m';
our $c_http_client_failure = '[38;2;235;41;41m';
our $c_http_server_error   = '[38;5;199;1m';


## Output configuration:  ######################################################

sub nowarn (&;@) { local $SIG{__WARN__} = sub { }; $_[0]->(@_) }

my $linestart     = "${c_sym}‚óè${c0} ";
my $metalinestart = "${c_meta}‚óè${c0} ";
my $contlinestart = "${c_contsym}‚óè${c0} ";

my $followsep     = $c_followsep . ("‚Åª" x nowarn{ (GetTerminalSize())[0] // 80 }) . "${c0}\n";

# As soon as the <> read pauses for more than 200ms, we print a separator line.
# This serves to separate "tail -f"'s past output from future output.
# This only happens once.
# This only happens if there was some previous output (we don't need in case of "tail -f -n0").
my $do_linesep = 200;


## Line-separator functions:  ##################################################

my $had_output = 0;  # true after some visible input has been printed

sub stop_linesep_wait () {
	return unless $do_linesep;
	ualarm(0);
	$SIG{'ALRM'} = 'DEFAULT';
}

sub start_linesep_wait () {
	return unless $do_linesep;
	$SIG{'ALRM'} = sub {
		stop_linesep_wait();
		undef $do_linesep;
		print $followsep  if $had_output;
	};
	ualarm($do_linesep * 1000);
}


## Main input loop:  ###########################################################

for (start_linesep_wait(); defined($_ = <>) && (stop_linesep_wait(), 1); start_linesep_wait()) {
	# every non-empty line is a full log line.
	if (m/^\s*$/) {
		print ; next
	}

	if (s/^$re_tail_filename//) {
		# `tail` file header
		print $metalinestart;
		print format_meta($+{'prefix'});
		print format_trace($+{'filename'}, $c_meta);
		print format_meta($+{'suffix'});
		next;
	}

	$had_output = 1;

	my $is_apache;
	my $is_postfix;
	my $is_rfc5424;
	my $is_dmesg;
	my $is_nginx_fastcgi;
	my $is_continuation_line = (m/^\s*(?:#\d+\b|URI:|Referr?er:|User-?[Aa]gent:|Stack trace:$|CLI:|  thrown in | {16,})/);
	if ($is_continuation_line) {
		print $contlinestart;
	} else {
		print $linestart;
	}

	my $suffix = '';
	my ($message_isolated, $loglevel_isolated, $exception_isolated, $text_isolated);

	# The start is probably the timestamp:
	if (s/^($re_ddd {1,2}$re_time) ($re_host) ($re_app)(: *)//) {
		# syslog format
		print format_date($1) . ' ';
		print format_host($2) . ' ';
		#print format_app($3 . $4) . '';
		print format_app($3 . $4);
		$is_postfix = 1  if ($3 =~ m/^postfix/);
		$message_isolated = 1;
	} elsif (s/^($re_ddd {1,2}$re_time) ($re_host) (\d+) ($re_ts8601) ($re_host) ($re_app|-) (\d+|-) (\S+) //) {
		# syslog RFC-5424 format
		print format_date($1) . ' ';
		print format_host($2) . ' ';
		print format_info_prefix($3) . ' ';
		print format_date($4) . ' ';
		print format_host($5) . ' ';
		print format_app($6) . ' ';
		print format_app($7) . ' ';  # PID
		print format_info_prefix($8) . ' ';  # msgid
		$message_isolated = 1;
		$is_rfc5424 = 1;
	} elsif (s/^(\[$re_ymd $re_time\]) ($re_app)(\.[A-Z]+)?(: *)//) {
		# symfony format
		print format_date($1) . ' ';
		print format_app($2);
		print format_loglevel($3 . $4);
		$message_isolated = 1;
		$loglevel_isolated = 1;
	} elsif (s/^(\[$re_word $re_word \d+ $re_time$re_ms? \d{4}\]) +(\[\w*:\w+\]) +(\[(?:pid )?\d+(?:[,:]tid \d+)?\]) +($re_a2clnt )?//) {
		# Apache2 error format
		print format_date($1) . ' ';
		print format_loglevel($2) . ' ';
		print format_app($3) . ' ';
		print format_info_prefix($4)  if $4;
		$is_apache = 1;
		$message_isolated = 1;
		$loglevel_isolated = 1;
	} elsif (s/^(?<vh>$re_client(?::\d+)?) (?<cl>$re_client|-) (?<id>\S+) (?<un>\S+) (?<ts>$re_a2date) (?=")// ||
	         s/^(?<cl>$re_client|-) (?<id>\S+) (?<un>\S+) (?<ts>$re_a2date) (?=")//) {
		# Apache2 custom format
		print format_host($+{'vh'}) . ' '  if $+{'vh'};
		print format_info_prefix($+{'cl'}) . ' ';  # client addr/hostname
		print format_info_prefix($+{'id'}) . ' ';  # identd logname
		print format_info_prefix($+{'un'}) . ' ';  # http basic username
		print format_date($+{'ts'}) . ' ';
		$is_apache = 1;
		$message_isolated = 1;
	} elsif (s/^($re_ts8601) (\d+) (\[\w+\]) ($re_mysqld)?// ||
		 s/^(${re_ymd} ${re_time}) (\d+) (\[\w+\]) ($re_mysqld)?//) {
		# mysqld error:
		print format_date($1) . ' ';
		print format_info_prefix($2) . ' ';
		print format_loglevel($3) . ' ';
		print format_app($4)  if $4;
		$message_isolated = 1;
		$loglevel_isolated = 1;
	} elsif (s/^($re_dmesg_ts) ($re_dmesg_app:|\[$re_dmesg_app\])( |$)//) {
		# dmesg
		print format_date($1) . ' ';
		print format_app($2) . $3;
		$message_isolated = 1;
		$is_dmesg = 1;
	} elsif (s/^($re_dmesg_ts) //) {
		# dmesg (other)
		print format_date($1) . ' ';
		$is_dmesg = 1;
	} elsif (s/^(Next) ($re_exception)(: )//) {
		# Euv continuation:
		print format_date($1) . ' ';
		print format_exception($2) . '';
		print $3;
		$message_isolated = 1;
	} elsif (s/^(PHP Fatal error: )( ?Uncaught )($re_exception)//) {
		print format_app($1);
		print $2;
		print format_exception($3);
		$message_isolated = 1;
	} elsif (s/^($re_ymd $re_time(?:,\d+)?:)($re_loglevel:)([^:]+:)//) {
		# LetsEncrypt/certbot
		print format_date($1);
		print format_loglevel($2);
		print format_app($3);
		$message_isolated = 1;
		$loglevel_isolated = 1;
	} elsif (s/^($re_ymd $re_time(?:,\d+)?)( - )(\w[^\[]*)(\[$re_loglevel\]: )//) {
		# cloud-init
		print format_date($1 . $2);
		print format_app($3);
		print format_loglevel($4);
		$message_isolated = 1;
		$loglevel_isolated = 1;
	} elsif (s/^($re_ymd $re_time$re_ms? )(\[$re_loglevel\] )?(\d+(?:#\d+)?: )(\*\d+ ?)?(FastCGI sent in (?:stderr|stdout): )(")//i) {
		# nginx + fastcgi
		print format_date($1);
		print format_loglevel($2)  if $2;
		print format_app($3);
		print format_info_prefix($4)  if $4;
		print format_info_prefix($5);
		print $c_bold . format_info_prefix($6) . $c_unbold  if $6;
		$is_nginx_fastcgi = 1;
		$message_isolated = 1;
		$loglevel_isolated = 1  if $2;
		if (s/(")((?: while reading response header from upstream)?, client: ${re_client}, (?:server:|request:).*)$//s) {
			# end of fastcgi message should not affect main message parsing, it's a mostly boring wrapper -- so cut it out and put it into $suffix
			$suffix = $c_bold . format_info_prefix($1) . $c_unbold . format_info($2) . $suffix;
		}
	} elsif (s/^($re_ymd $re_time$re_ms?|$re_ts8601|$re_tsw|\[$re_ymd $re_time$re_ms?\])( |:|$)//) {
		print format_date($1 . $2);
		$message_isolated = 1;
	}

	if ($is_dmesg && s/^((-{3,}) ?[\[\(].+[\]\)] ?-{3,}\s*)//) {
		print format_info($1);
	} elsif (s/^(message repeated \d+ times: \[)(\s*)//) {
		print format_rpt($1);
		print $2;
		if (s/(\s*\]\s*)$//) {
			$suffix = format_rpt($1) . $suffix;
		}
	}

	if ($message_isolated && !$loglevel_isolated && s/^(<$re_loglevel>  ?|\[$re_loglevel\][: ]|$re_loglevel:  ?)//) {
		print format_loglevel($1);
		$loglevel_isolated = 1;
	} elsif ($message_isolated && !$loglevel_isolated && s/^($re_loglevel) (\[\S+\]) ([a-z]+(?:\.\w+)+ )?//) {
		# LOGLEVEL [component] org.java.classname
		print format_loglevel($1) . ' ';
		print format_app($2) . ' ';
		print format_info_prefix($3)  if $3;
		$loglevel_isolated = 1;
	} elsif ($message_isolated && !$loglevel_isolated && s/^($re_loglevel) (\($re_path$re_lineno?\): )//) {
		# LOGLEVEL (FILENAME.PY:LINENO):
		print format_loglevel($1) . ' ';
		print format_info_prefix($2);
		$loglevel_isolated = 1;
	}

	my $re_info_brackets = '(?:\\[[^\\]]+\\])';
	if ($message_isolated && s/^($re_info_brackets(?: *$re_info_brackets)*)( *)//) {
		print format_info_prefix($1, ($is_rfc5424 ? 'RFC5424' : undef));
		print $2;
	} elsif ($message_isolated && $is_rfc5424 && s/^(-) //) {
		# RFC5424 with empty Structured Data field
		print format_info_prefix($1) . ' ';
	}

	if ($message_isolated && !$loglevel_isolated && s/^(<$re_loglevel>  ?|$re_loglevel:  ?)//) {
		print format_loglevel($1);
		$loglevel_isolated = 1;
	}

	if ($message_isolated && s/^( *(?:PHP message:  ?)?(?:PHP Fatal error:  ?)?(?:Uncaught )?)($re_exception)(: +)//) {
		print $1;
		print format_exception($2);
		print $3;
		$exception_isolated = 1;
	}

	if ($message_isolated && $is_apache && s/^($re_a2err:) //) {
		# apache2: "AH01620: Could not open..."
		print format_exception($1) . ' ';
		$exception_isolated = 1;
	} elsif ($message_isolated && $is_apache && s/^((?:\(\d+\))?\w+(?: \w+)*: )($re_a2clnt )?($re_a2err:) //) {
		# apache2: "(13)Permission denied: [client 00.000.000.00:0000] AH01620: Could not open..."
		print $1;
		print $2  if $2;
		print format_exception($3) . ' ';
		$exception_isolated = 1;
	}

#	if ($message_isolated && s/^(?:($re_info_brackets +)+)//) {
#		print format_info($1);
#	}

	if ($message_isolated && s#^(.+?)(  ?\(stack: .+\))?( \($re_exception (?:@|at|in) $re_path$re_lineno?\))##) {
		# AEH format
		my ($message, $stack, $rest, $info) = ($1, $2, $3, undef);
		if ($message =~ s/((?: $re_info_brackets)+)$//) { $info = $1; }
		print format_message($message);
		print format_info($info)  if $info;
		print format_stack($stack)  if $stack;
		print format_trace($rest);
		$text_isolated = 1;
	} elsif ($message_isolated && s#^(.+?)( (?:in|at) $re_abspath(?:$re_lineno)?\b)(\s*$)##) {
		# "MESSAGE in FILE:LINE" format
		print format_message($1);
		print format_trace($2);
		print $3;
		$text_isolated = 1;
	} elsif ($message_isolated && s#^(.+?)(?:(  ?)($re_info_brackets))?(  ?(?:in|at) $re_abspath(?:$re_lineno)?\b {1,2})(?=[\(\[])##) {
		# mini-api format
		print format_message($1);
		print $2 . format_info($3);
		print format_trace($4);
		print $5;
		$text_isolated = 1;
	} elsif ($message_isolated && s#("[A-Z]\w* [^"]+?") (\d+)( .*)$##) {
		# Apache2 log
		print format_message($1) . ' ';
		print format_http($2);
		print format_info($3);
		$text_isolated = 1;
	} elsif ($message_isolated && $is_postfix) {
		s/(?<=dsn=)([\d\.]+)(?=, status=)/ format_postfix_status($1) /e;
		s/\b(dsn|status|from|to|orig_to|relay|client|message-id)(=)/ $c_bold . $1 . $c_unbold . $2 /ge;
	}


	if ($is_continuation_line && s/^(#\d+ )?($re_abspath(?:$re_lineno)?)(: )($re_fncall)//) {
		print format_info($1)  if $1;
		print format_trace($2) . $3 . format_fncall($4);
	} elsif ($is_continuation_line) {
		# all continuation lines get info-colored:
		print $c_info;
	}

	if ($message_isolated && s/^($re_info_brackets(?: +$re_info_brackets)*)//) {
		print format_info($1);
	}

	# Stack trace:
	s/(\((?:trace|back ?trace|stack ?trace|call ?stack): .+?\))( |$)/format_trace($1) . $2/e;

	# Trailing Symfony JSON data:
	if ($message_isolated) {
		s/ ((?=\{")$re_json) (?=\[)/' ' . format_json($1) . ' '/e;
		s/( \[\])$/format_info($1)/e;
	}

	# JSON-only line:
	if (!$message_isolated) {
		s/^((?=\{")$re_json)$/ format_json($1, '') /e;
	}

	if ($message_isolated && $is_postfix && s/(\s*\(.+\))$//) {
		$suffix = format_postfix_info($1) . $suffix;
	}

	if (s/([\r\n]+)$//) { $suffix .= $1 }
	print;
	print $suffix;
	flush STDOUT;
}

